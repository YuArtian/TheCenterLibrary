# 编译原理

将 template 模板编译成 render 函数
### $mount
```js
Vue.prototype.$mount = function (el) {
  const vm = this;
  const options = vm.$options;
  el = document.querySelector(el);

  // 如果没有render方法
  if (!options.render) {
    let template = options.template;
    // 如果没有模板但是有el
    if (!template && el) {
      // outerHTML 获取描述元素（包括其后代）的序列化 HTML 片段
      // https://developer.mozilla.org/zh-CN/docs/Web/API/Element/outerHTML
      template = el.outerHTML;
    }
    // 以 template 为模板 生成 render 函数
    const render= compileToFunctions(template);
    options.render = render;
  }
  // 挂载组件
  mountComponent(vm, el)
}
```
### renderMixin
```js
import { createElement, createTextVnode } from "./vdom/index.js";

// 在编译阶段时，AST 转换为这里的各种内部函数
export function renderMixin(Vue) {
  Vue.prototype._c = function (...args) {
    // 创建元素的虚拟节点
    return createElement(this, ...args);
  };
  Vue.prototype._v = function (text) {
    // 创建文本的虚拟节点
    return createTextVnode(this, text);
  };
  Vue.prototype._s = function (val) {
    // 转化成字符串
    return val == null
      ? ""
      : typeof val == "object"
      ? JSON.stringify(val)
      : val;
  };
  Vue.prototype._render = function () {
    // render
    const vm = this;
    let render = vm.$options.render; // 获取编译后的render方法

    // 调用render方法产生虚拟节点
    let vnode = render.call(vm); // _c(xxx,xx,xxx,xxx) 调用时会自动将变量进行取值，将实例结果进行渲染

    return vnode; // 虚拟节点

    // _c('div',{},_c())
  };
}
```
### compileToFunctions
```js
import { generate } from "./generate";
import { parseHTML } from "./parse";

export default function compileToFunctions(template) {
  // template 模板 -> AST
  let ast = parseHTML(template);
  // AST -> 可运行代码 code（字符串形式）
  let code = generate(ast);
  // 使用 with 将 code 组合成 render 函数
  let render = `with(this){return ${code}}`;
  // 使用 Function 将字符串 转换为 函数
  let fn = new Function(render);
  return fn;
}
```